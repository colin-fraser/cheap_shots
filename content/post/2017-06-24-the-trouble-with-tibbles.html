---
title: The trouble with tibbles
author: ~
date: '2017-06-24'
slug: the-trouble-with-tibbles
categories: []
tags: []
---



<p>Hadley Wickham’s <code>dplyr</code> package makes complex data manipulations easy to describe. However, dplyr functions all return “tibbles” rather than data.frames. Class tbl inherits from data.frame, so you can use tbls everywhere you use data.frames. Except when you can’t.</p>
<!--more-->
<p>Here’s one example that tripped me up recently.</p>
<pre class="r"><code>df &lt;- data.frame(a = 1:26,
                 b = letters)
sapply(df,class)</code></pre>
<pre><code>##         a         b 
## &quot;integer&quot;  &quot;factor&quot;</code></pre>
<pre class="r"><code>sum(df[,&quot;b&quot;] == &#39;b&#39;)</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>sum(as.character(df[,&quot;b&quot;],1,1) == &#39;b&#39;)</code></pre>
<pre><code>## [1] 1</code></pre>
<p>But now with tbl_df</p>
<pre class="r"><code>library(dplyr)</code></pre>
<pre><code>## 
## Attaching package: &#39;dplyr&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:stats&#39;:
## 
##     filter, lag</code></pre>
<pre><code>## The following objects are masked from &#39;package:base&#39;:
## 
##     intersect, setdiff, setequal, union</code></pre>
<pre class="r"><code>my_first_tbl &lt;- tbl_df(df)
my_first_tbl</code></pre>
<pre><code>## # A tibble: 26 x 2
##        a      b
##    &lt;int&gt; &lt;fctr&gt;
##  1     1      a
##  2     2      b
##  3     3      c
##  4     4      d
##  5     5      e
##  6     6      f
##  7     7      g
##  8     8      h
##  9     9      i
## 10    10      j
## # ... with 16 more rows</code></pre>
<p>So I don’t have to do <code>sapply(df, class)</code> to see what is going on with the contents. This is good. tbls also print out only what fits on the console, which is also nice.</p>
<p>But check this out:</p>
<pre class="r"><code>sum(my_first_tbl[,&quot;b&quot;] == &#39;b&#39;) ## works</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>sum(as.character(my_first_tbl[,&quot;b&quot;]) == &#39;b&#39;) ## !!</code></pre>
<pre><code>## [1] 0</code></pre>
<p>This threw me for longer than I care to admit. Especially embarrassing when a student comes with this problem and I don’t know the answer!</p>
<p>The reason is that <code>[.tbl_df()</code> has different default behavior from <code>[.data.frame</code> when extracting a single column.</p>
<pre class="r"><code>class(my_first_tbl[,&quot;b&quot;])</code></pre>
<pre><code>## [1] &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</code></pre>
<pre class="r"><code>class(df[,&quot;b&quot;])</code></pre>
<pre><code>## [1] &quot;factor&quot;</code></pre>
<p>Coercing a data.frame to character gives a different outcome than coercing a tbl_df. What gives? Turns out that <code>[.tbl_df()</code> has drop = FALSE while <code>[.data.frame</code> has drop = TRUE when the result has a single column. Never heard of drop you say? Check this out:</p>
<pre class="r"><code>class(df[,&quot;b&quot;, drop=FALSE])</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<pre class="r"><code>sum(as.character(df[,&quot;b&quot;, drop=FALSE],1,1) == &#39;b&#39;)</code></pre>
<pre><code>## [1] 0</code></pre>
<p>There are other differences too. For example, <code>data_frame()</code> by default does NOT convert strings to factors:</p>
<pre class="r"><code>my_second_tbl &lt;- data_frame(a = 1:26,
                            b = letters)
my_second_tbl</code></pre>
<pre><code>## # A tibble: 26 x 2
##        a     b
##    &lt;int&gt; &lt;chr&gt;
##  1     1     a
##  2     2     b
##  3     3     c
##  4     4     d
##  5     5     e
##  6     6     f
##  7     7     g
##  8     8     h
##  9     9     i
## 10    10     j
## # ... with 16 more rows</code></pre>
<p>I think I’m a fan of tibbles, but even if I’m not I am in love with dplyr, so I’d better get used to tibbles.</p>
